# SATCON 优化算法设计方案

> 本文档详细描述如何在 SATCON 框架下引入两个核心优化算法：
> 1. **Pair-wise 模式选择优化**（替代启发式规则）
> 2. **S2A 资源分配优化**（消除 DF 瓶颈）

---

## 一、当前 Baseline 实现分析

### 1.1 模式选择启发式规则（现状）

**位置**：[satcon_system.py:178-232](../src/satcon_system.py#L178-L232)

**实现**：基于 4 条 if-else 规则进行决策

```python
def hybrid_decision(self, sat_rates, abs_noma_rates, abs_oma_rates, sat_pairs):
    """
    混合NOMA/OMA决策规则（逐对，4条规则）
    """
    for k, (weak_idx, strong_idx) in enumerate(sat_pairs):
        R_s_i = sat_rates[weak_idx]      # 卫星直达-弱用户
        R_s_j = sat_rates[strong_idx]    # 卫星直达-强用户
        R_dn_i = abs_noma_rates[weak_idx]   # ABS NOMA-弱用户
        R_dn_j = abs_noma_rates[strong_idx] # ABS NOMA-强用户
        R_do_i = abs_oma_rates[weak_idx]    # ABS OMA-弱用户
        R_do_j = abs_oma_rates[strong_idx]  # ABS OMA-强用户

        # 规则1：NOMA双用户 (两者都通过ABS更好)
        if R_s_i < R_dn_i and R_s_j < R_dn_j:
            modes.append('noma')

        # 规则2：OMA只给弱用户
        elif R_s_i < R_do_i and R_s_j >= R_dn_j:
            modes.append('oma_weak')

        # 规则3：OMA只给强用户
        elif R_s_i >= R_dn_i and R_s_j < R_do_j:
            modes.append('oma_strong')

        # 规则4：不转发（卫星直达）
        else:
            modes.append('sat')
```

**问题**：
- ❌ 无法保证 pair-wise 最优（甚至局部最优）
- ❌ 规则顺序依赖（先检查 NOMA 再检查 OMA）
- ❌ 未考虑资源利用率（例如某 pair 占用整个 Bd/K 只服务 1 个用户）

---

### 1.2 S2A 资源分配（现状）

**位置**：[satcon_system.py:262](../src/satcon_system.py#L262)

**实现**：固定均分 Bs/K

```python
def compute_s2a_rates(self, sat_pairs, ...):
    K = len(sat_pairs)
    Bs_per_pair = self.config.Bs / K  # 固定均分！

    # 后续计算每对的 S2A 速率
    for k in range(K):
        rate_s2a_strong = Bs_per_pair * np.log2(...)
        rate_s2a_weak = Bs_per_pair * np.log2(...)
```

**问题**：
- ❌ 与 ABS 实际服务用户集合无关（无论是 NOMA/OMA/SAT，S2A 都分配 Bs/K）
- ❌ 未考虑 Decode-and-Forward 瓶颈（某些 pair 可能根本不需要 ABS 转发）
- ❌ 资源浪费（不转发的 pair 仍占用 S2A 带宽）

---

## 二、优化算法设计方案

### 2.1 Pair-wise 模式选择优化

#### 2.1.1 优化目标

对每个卫星用户对 \((i,j)\)，选择最优传输模式以最大化 pair 总速率：

$$
\max_{m_k \in \{\text{SAT},\,\text{NOMA},\,\text{OMA-W},\,\text{OMA-S}\}} \quad R_i(m_k) + R_j(m_k)
$$

其中：
- **SAT**：两用户都通过卫星直达
  - \( R_i = R_s^i, \quad R_j = R_s^j \)
- **NOMA**：两用户都通过 ABS NOMA
  - \( R_i = \min(R_{dn}^i, R_{s2a}^i), \quad R_j = \min(R_{dn}^j, R_{s2a}^j) \)
- **OMA-W**：只给弱用户 i，强用户 j 用卫星
  - \( R_i = \min(R_{do}^i, R_{s2a}^i), \quad R_j = R_s^j \)
- **OMA-S**：只给强用户 j，弱用户 i 用卫星
  - \( R_i = R_s^i, \quad R_j = \min(R_{do}^j, R_{s2a}^j) \)

#### 2.1.2 算法选择

**方案 A：穷举搜索（推荐）**

```python
def optimize_mode_selection_exhaustive(self, sat_rates, abs_noma_rates,
                                       abs_oma_rates, sat_pairs):
    """
    穷举所有模式组合，选择全局最优

    复杂度：O(4^K) - 对于 K=4，只有 256 种组合
    """
    K = len(sat_pairs)
    modes_options = ['sat', 'noma', 'oma_weak', 'oma_strong']

    best_sum_rate = 0
    best_modes = None
    best_rates = None

    # 穷举所有可能的模式组合
    from itertools import product
    for mode_combo in product(modes_options, repeat=K):
        # 计算该组合下的总速率
        rates = np.zeros(2*K)
        for k, (weak_idx, strong_idx) in enumerate(sat_pairs):
            mode = mode_combo[k]

            if mode == 'sat':
                rates[weak_idx] = sat_rates[weak_idx]
                rates[strong_idx] = sat_rates[strong_idx]
            elif mode == 'noma':
                rates[weak_idx] = abs_noma_rates[weak_idx]
                rates[strong_idx] = abs_noma_rates[strong_idx]
            elif mode == 'oma_weak':
                rates[weak_idx] = abs_oma_rates[weak_idx]
                rates[strong_idx] = sat_rates[strong_idx]
            elif mode == 'oma_strong':
                rates[weak_idx] = sat_rates[weak_idx]
                rates[strong_idx] = abs_oma_rates[strong_idx]

        total_rate = np.sum(rates)
        if total_rate > best_sum_rate:
            best_sum_rate = total_rate
            best_modes = mode_combo
            best_rates = rates.copy()

    return best_rates, list(best_modes)
```

**方案 B：贪心算法（快速近似）**

```python
def optimize_mode_selection_greedy(self, sat_rates, abs_noma_rates,
                                   abs_oma_rates, sat_pairs):
    """
    贪心选择：逐对选择收益最大的模式

    复杂度：O(K) - 线性时间
    """
    final_rates = sat_rates.copy()
    modes = []

    for k, (weak_idx, strong_idx) in enumerate(sat_pairs):
        # 计算各模式的收益
        gains = {
            'sat': sat_rates[weak_idx] + sat_rates[strong_idx],
            'noma': abs_noma_rates[weak_idx] + abs_noma_rates[strong_idx],
            'oma_weak': abs_oma_rates[weak_idx] + sat_rates[strong_idx],
            'oma_strong': sat_rates[weak_idx] + abs_oma_rates[strong_idx]
        }

        # 选择最优模式
        best_mode = max(gains, key=gains.get)
        modes.append(best_mode)

        # 更新速率
        if best_mode == 'noma':
            final_rates[weak_idx] = abs_noma_rates[weak_idx]
            final_rates[strong_idx] = abs_noma_rates[strong_idx]
        elif best_mode == 'oma_weak':
            final_rates[weak_idx] = abs_oma_rates[weak_idx]
        elif best_mode == 'oma_strong':
            final_rates[strong_idx] = abs_oma_rates[strong_idx]

    return final_rates, modes
```

**方案 C：整数线性规划（ILP）**

```python
def optimize_mode_selection_ilp(self, sat_rates, abs_noma_rates,
                                abs_oma_rates, sat_pairs):
    """
    ILP 形式化求解

    决策变量：x_k^m ∈ {0,1}，表示第 k 对选择模式 m
    约束：∑_m x_k^m = 1 (每对恰好一个模式)
    目标：max ∑_k ∑_m x_k^m * R_k^m
    """
    from scipy.optimize import linprog
    # 实现略（需要 MILP 求解器）
    pass
```

#### 2.1.3 推荐方案

**论文发表**：方案 A（穷举）+ 方案 B（贪心）
- 穷举保证全局最优（作为性能上界）
- 贪心作为低复杂度基准（对比 baseline）
- 复杂度分析：O(4^K) vs O(4·K·log(K))（启发式）

**实际部署**：方案 B（贪心）
- K=4 时，4 种模式 × 4 对 = 16 次比较，极低延迟

---

### 2.2 S2A 资源分配优化

#### 2.2.1 优化目标

**基本形式**（假设模式已确定）：

$$
\max_{\{b_k\}} \sum_{k=1}^K \sum_{l \in \text{pair}_k} \min\left( R_l^{A2G}(b_k),\, R_l^{S2A}(b_k) \right)
$$

$$
\text{s.t.} \quad \sum_{k=1}^K b_k \le B_s, \quad b_k \ge 0
$$

**物理意义**：
- \( R_l^{A2G} \)：ABS → 用户的速率（已知，与 \( b_k \) 无关）
- \( R_l^{S2A}(b_k) \)：卫星 → ABS 的解码速率（正比于 \( b_k \)）
- \( \min(\cdot) \)：Decode-and-Forward 瓶颈

**关键洞察**：
- 只有 **ABS 转发**的 pair（模式为 NOMA/OMA-W/OMA-S）需要 S2A 带宽
- SAT 模式的 pair 不需要分配 S2A 带宽（\( b_k = 0 \)）

#### 2.2.2 数学推导

对于模式为 NOMA 的 pair \( k \)（弱用户 \( i \)，强用户 \( j \)）：

$$
R_i^{S2A}(b_k) = b_k \cdot \log_2\left(1 + \frac{\beta_i \cdot \text{SNR} \cdot h_{s2a}}{1 + \beta_j \cdot \text{SNR} \cdot h_{s2a}}\right)
$$

$$
R_j^{S2A}(b_k) = b_k \cdot \log_2(1 + \beta_j \cdot \text{SNR} \cdot h_{s2a})
$$

**瓶颈分析**：
- 若 \( R_i^{A2G} < R_i^{S2A}(b_k) \)，则增加 \( b_k \) 无益（瓶颈在 A2G）
- 最优分配：\( b_k^* \) 使得 \( R_i^{S2A}(b_k^*) = R_i^{A2G} \)（恰好消除瓶颈）

#### 2.2.3 算法选择

**方案 A：KKT 条件 + 闭式解（推荐）**

由于目标函数是凸的（对数凹函数的 min），可推导 KKT 条件：

$$
\frac{\partial}{\partial b_k} \sum_l \min(R_l^{A2G}, R_l^{S2A}(b_k)) = \lambda \quad \text{(Lagrange 乘子)}
$$

**算法步骤**：

```python
def optimize_s2a_allocation_kkt(self, sat_pairs, modes, a2g_rates,
                                snr_linear, h_s2a, sat_power_factors):
    """
    基于 KKT 条件的 S2A 带宽分配

    核心思路：
    1. 只给 ABS 转发的 pair 分配带宽
    2. 分配量使得 R_s2a ≈ R_a2g（消除瓶颈）
    3. 若总需求超过 Bs，按比例缩减
    """
    K = len(sat_pairs)
    b_optimal = np.zeros(K)

    for k in range(K):
        mode = modes[k]

        # 规则 1：SAT 模式不需要 S2A 带宽
        if mode == 'sat':
            b_optimal[k] = 0
            continue

        weak_idx, strong_idx = sat_pairs[k]

        # 计算目标速率（A2G 瓶颈）
        if mode == 'noma':
            R_target_weak = a2g_rates[weak_idx]
            R_target_strong = a2g_rates[strong_idx]
            # 取二者中更严格的约束
            R_target = max(R_target_weak, R_target_strong)
        elif mode == 'oma_weak':
            R_target = a2g_rates[weak_idx]
        elif mode == 'oma_strong':
            R_target = a2g_rates[strong_idx]

        # 计算所需带宽（反解 b_k）
        # R_target = b_k * log2(1 + SNR * h_s2a)
        # => b_k = R_target / log2(1 + SNR * h_s2a)
        beta = sat_power_factors['beta_weak'][k]  # 根据模式选择
        snr_eff = snr_linear * h_s2a

        if mode == 'noma':
            # NOMA SIC：弱用户瓶颈
            snr_weak = beta * snr_eff / (1 + (1-beta) * snr_eff)
            b_optimal[k] = R_target_weak / np.log2(1 + snr_weak)
        else:
            # OMA：全功率
            b_optimal[k] = R_target / np.log2(1 + snr_eff)

    # 规则 2：若总需求超过 Bs，按比例缩减
    total_demand = np.sum(b_optimal)
    if total_demand > self.config.Bs:
        scaling_factor = self.config.Bs / total_demand
        b_optimal *= scaling_factor

    return b_optimal
```

**方案 B：Water-filling 算法**

```python
def optimize_s2a_allocation_waterfilling(self, sat_pairs, modes,
                                         channel_gains_s2a):
    """
    Water-filling：优先分配给信道条件好的 pair

    适用场景：S2A 信道增益差异大（仰角不同、遮挡等）
    """
    K = len(sat_pairs)

    # 1. 计算各 pair 的"水位"（速率/带宽斜率）
    slopes = []
    for k in range(K):
        if modes[k] == 'sat':
            slopes.append(0)  # 不参与分配
        else:
            # 斜率 ≈ log2(1 + SNR * h_s2a)
            slopes.append(np.log2(1 + channel_gains_s2a[k]))

    # 2. Water-filling：迭代分配
    b_optimal = np.zeros(K)
    remaining_bandwidth = self.config.Bs

    while remaining_bandwidth > 0:
        # 找到斜率最大的 pair
        max_slope_idx = np.argmax(slopes)
        if slopes[max_slope_idx] == 0:
            break

        # 分配增量带宽
        delta_b = min(remaining_bandwidth, 0.1 * self.config.Bs / K)
        b_optimal[max_slope_idx] += delta_b
        remaining_bandwidth -= delta_b

        # 更新斜率（边际效应递减）
        # 简化：假设线性递减
        slopes[max_slope_idx] *= 0.9

    return b_optimal
```

**方案 C：交替优化（模式 + 资源联合）**

```python
def joint_optimization_alternating(self, ...):
    """
    交替优化模式选择和 S2A 分配

    步骤：
    1. 固定 S2A 分配，优化模式选择（穷举）
    2. 固定模式，优化 S2A 分配（KKT）
    3. 迭代直到收敛
    """
    max_iter = 10
    for _ in range(max_iter):
        # Step 1: 优化模式
        modes_new = self.optimize_mode_selection_exhaustive(...)

        # Step 2: 优化 S2A
        b_new = self.optimize_s2a_allocation_kkt(modes_new, ...)

        # 检查收敛
        if np.allclose(b_new, b_old):
            break
        b_old = b_new.copy()

    return modes_new, b_new
```

#### 2.2.4 推荐方案

**论文发表**：方案 A（KKT）+ 方案 C（联合优化）
- KKT 提供理论最优解（凸优化保证）
- 联合优化展示跨层设计能力

**实际部署**：方案 A（KKT）
- 闭式解，无需迭代
- 计算复杂度 O(K)

---

## 三、集成方案与代码架构

### 3.1 模块划分

```
src/
├── satcon_system.py              # 主系统（原有）
├── optimizers/                   # 新增：优化器模块
│   ├── __init__.py
│   ├── mode_selector.py          # 模式选择优化
│   │   ├── ExhaustiveSelector
│   │   ├── GreedySelector
│   │   └── HeuristicSelector (原 baseline)
│   └── resource_allocator.py     # S2A 资源分配优化
│       ├── KKTAllocator
│       ├── WaterFillingAllocator
│       └── UniformAllocator (原 baseline)
└── experiments/
    └── compare_optimization_schemes.py  # 性能对比
```

### 3.2 接口设计

#### 模式选择器基类

```python
# src/optimizers/mode_selector.py
from abc import ABC, abstractmethod

class ModeSelector(ABC):
    """模式选择器基类"""

    @abstractmethod
    def select_modes(self, sat_rates, abs_noma_rates, abs_oma_rates, sat_pairs):
        """
        选择传输模式

        返回:
            final_rates: 最终速率 [N]
            modes: 选择的模式列表 ['sat', 'noma', 'oma_weak', 'oma_strong']
        """
        pass

class HeuristicSelector(ModeSelector):
    """原 baseline 启发式规则（4条规则）"""
    def select_modes(self, ...):
        # 原 hybrid_decision 逻辑
        pass

class ExhaustiveSelector(ModeSelector):
    """穷举搜索（全局最优）"""
    def select_modes(self, ...):
        # 方案 2.1.2-A
        pass

class GreedySelector(ModeSelector):
    """贪心算法（快速近似）"""
    def select_modes(self, ...):
        # 方案 2.1.2-B
        pass
```

#### 资源分配器基类

```python
# src/optimizers/resource_allocator.py
from abc import ABC, abstractmethod

class S2AAllocator(ABC):
    """S2A 带宽分配器基类"""

    @abstractmethod
    def allocate_bandwidth(self, sat_pairs, modes, a2g_rates, ...):
        """
        分配 S2A 带宽

        返回:
            b_allocated: 各 pair 的带宽分配 [K]
        """
        pass

class UniformAllocator(S2AAllocator):
    """原 baseline 均分策略"""
    def allocate_bandwidth(self, sat_pairs, modes, ...):
        K = len(sat_pairs)
        return np.ones(K) * (Bs / K)

class KKTAllocator(S2AAllocator):
    """KKT 条件优化分配"""
    def allocate_bandwidth(self, ...):
        # 方案 2.2.3-A
        pass

class WaterFillingAllocator(S2AAllocator):
    """Water-filling 算法"""
    def allocate_bandwidth(self, ...):
        # 方案 2.2.3-B
        pass
```

### 3.3 系统集成

修改 `SATCONSystem` 类以支持可插拔的优化器：

```python
# src/satcon_system.py
class SATCONSystem:
    def __init__(self, config_obj, abs_bandwidth,
                 mode_selector='heuristic',      # 新增参数
                 s2a_allocator='uniform'):        # 新增参数

        # 初始化优化器
        from src.optimizers.mode_selector import (
            HeuristicSelector, ExhaustiveSelector, GreedySelector
        )
        from src.optimizers.resource_allocator import (
            UniformAllocator, KKTAllocator
        )

        # 模式选择器
        if mode_selector == 'heuristic':
            self.mode_selector = HeuristicSelector()
        elif mode_selector == 'exhaustive':
            self.mode_selector = ExhaustiveSelector()
        elif mode_selector == 'greedy':
            self.mode_selector = GreedySelector()

        # S2A 分配器
        if s2a_allocator == 'uniform':
            self.s2a_allocator = UniformAllocator()
        elif s2a_allocator == 'kkt':
            self.s2a_allocator = KKTAllocator()

    def simulate_single_realization(self, snr_db, elevation_deg, seed):
        # ... (前面步骤不变)

        # 7. 【新】使用可配置的 S2A 分配器
        b_allocated = self.s2a_allocator.allocate_bandwidth(
            sat_pairs, modes_temp, a2g_rates, ...
        )
        s2a_rates = self.compute_s2a_rates_with_allocation(
            sat_pairs, b_allocated, ...
        )

        # 9. 【新】使用可配置的模式选择器
        final_rates, modes = self.mode_selector.select_modes(
            sat_rates, abs_noma_rates, abs_oma_rates, sat_pairs
        )

        return np.sum(final_rates), modes
```

---

## 四、性能评估与对比实验

### 4.1 对比方案

| 方案编号 | 模式选择 | S2A 分配 | 说明 |
|---------|---------|---------|------|
| Baseline | Heuristic | Uniform | 原论文方案 |
| Opt-M | Exhaustive | Uniform | 仅优化模式选择 |
| Opt-S | Heuristic | KKT | 仅优化 S2A 分配 |
| Opt-Full | Exhaustive | KKT | 全优化 |
| Opt-Fast | Greedy | KKT | 低复杂度全优化 |

### 4.2 评估指标

1. **性能指标**
   - Sum Rate (bits/s)
   - Spectral Efficiency (bits/s/Hz)
   - Outage Probability (低 SNR 下)

2. **复杂度指标**
   - 运行时间（ms）
   - 函数调用次数

3. **模式分布**
   - NOMA / OMA-W / OMA-S / SAT 各模式占比

### 4.3 实验脚本

```python
# experiments/compare_optimization_schemes.py
import numpy as np
import matplotlib.pyplot as plt
from config import config
from src.satcon_system import SATCONSystem

def run_comparison():
    snr_range = np.arange(-10, 31, 5)
    schemes = {
        'Baseline': ('heuristic', 'uniform'),
        'Opt-M': ('exhaustive', 'uniform'),
        'Opt-S': ('heuristic', 'kkt'),
        'Opt-Full': ('exhaustive', 'kkt'),
        'Opt-Fast': ('greedy', 'kkt')
    }

    results = {}
    for name, (mode_sel, s2a_alloc) in schemes.items():
        print(f"\n运行 {name}...")

        satcon = SATCONSystem(
            config,
            abs_bandwidth=1.2e6,
            mode_selector=mode_sel,
            s2a_allocator=s2a_alloc
        )

        mean_rates, mean_se, _, mode_stats = satcon.simulate_performance(
            snr_db_range=snr_range,
            n_realizations=100
        )

        results[name] = {
            'se': mean_se,
            'modes': mode_stats
        }

    # 绘图
    plot_comparison(snr_range, results)

if __name__ == "__main__":
    run_comparison()
```

---

## 五、预期性能增益与发表策略

### 5.1 预期增益

**模式选择优化（Opt-M vs Baseline）**：
- 预期增益：5-15%（取决于 SNR 区间）
- 主要来源：消除启发式规则的次优决策
- 高 SNR 下更明显（ABS 转发优势显著）

**S2A 资源分配优化（Opt-S vs Baseline）**：
- 预期增益：10-20%
- 主要来源：消除 DF 瓶颈，避免带宽浪费
- 低 SNR 下更明显（S2A 成为瓶颈）

**联合优化（Opt-Full vs Baseline）**：
- 预期增益：15-30%
- 交叉增益效应（模式与资源的耦合优化）

### 5.2 论文写作建议

**标题**：
- "Optimized Mode Selection and Resource Allocation for Satellite-Aerial Hybrid NOMA Systems"
- 或："Joint Optimization Framework for SATCON: Beyond Heuristic Decision Rules"

**贡献点**：
1. 形式化 SATCON 的模式选择为离散优化问题，提出全局最优解（穷举）和低复杂度近似（贪心）
2. 推导 S2A 带宽分配的 KKT 最优性条件，提出闭式解
3. 设计联合优化框架，实现跨层协同
4. 实验验证：相比 baseline 提升 XX%，同时保持低复杂度

**Related Work 对比**：
- SATCON 原论文：系统框架创新，算法层面启发式
- 本工作：保留系统框架，升级为优化驱动的决策

---

## 六、实现路线图

### Phase 1：基础实现（1-2 周）
- [x] 分析当前 baseline 代码
- [ ] 实现 `ExhaustiveSelector` 和 `GreedySelector`
- [ ] 实现 `KKTAllocator`
- [ ] 修改 `SATCONSystem` 支持可插拔优化器

### Phase 2：性能评估（1 周）
- [ ] 编写对比实验脚本
- [ ] 运行完整 Monte Carlo 仿真
- [ ] 绘制性能曲线（SE vs SNR）
- [ ] 统计模式分布和复杂度

### Phase 3：算法改进（可选，1 周）
- [ ] 实现 `WaterFillingAllocator`
- [ ] 实现联合优化（交替迭代）
- [ ] 超参数调优（如贪心策略的排序指标）

### Phase 4：论文撰写（2 周）
- [ ] 问题形式化（数学推导）
- [ ] 算法伪代码
- [ ] 复杂度分析（理论证明）
- [ ] 实验结果分析

---

## 七、技术风险与缓解措施

### 7.1 风险清单

**风险 1**：穷举搜索在 K > 5 时复杂度爆炸（4^K）
- **缓解**：论文中主要展示 K=4（256 组合，可接受），K > 5 用贪心算法

**风险 2**：KKT 分配可能出现数值不稳定（log2 中 SNR 过小）
- **缓解**：添加下界保护（SNR < threshold 时强制 b_k = 0）

**风险 3**：联合优化可能不收敛
- **缓解**：设置最大迭代次数，记录收敛曲线

### 7.2 验证策略

1. **单元测试**：每个优化器独立测试（固定输入，验证输出）
2. **对比测试**：优化方案的速率 ≥ baseline（单调性）
3. **边界测试**：极端 SNR（-10dB, 50dB）、极端信道条件

---

## 八、附录：关键公式推导

### A. S2A NOMA 速率公式

对于 pair \( k \)（弱用户 \( i \)，强用户 \( j \)），卫星发送 NOMA 信号：

$$
s = \sqrt{\beta_j P_s} x_j + \sqrt{\beta_i P_s} x_i, \quad \beta_i + \beta_j = 1
$$

ABS 接收信号（S2A 链路）：

$$
y_{ABS} = h_{s2a} \cdot s + n_{s2a}
$$

SIC 解码：
1. 先解码强用户 \( j \)（将 \( i \) 视为噪声）：
   $$
   R_{s2a,j} = b_k \cdot \log_2\left(1 + \frac{\beta_j P_s |h_{s2a}|^2}{N_{sd}}\right)
   $$

2. 消除 \( j \) 后解码弱用户 \( i \)：
   $$
   R_{s2a,i} = b_k \cdot \log_2\left(1 + \frac{\beta_i P_s |h_{s2a}|^2}{\beta_j P_s |h_{s2a}|^2 + N_{sd}}\right)
   $$

### B. KKT 最优性条件

优化问题：

$$
\max_{b_k} \sum_k f_k(b_k), \quad \text{s.t.} \sum_k b_k \le B_s
$$

Lagrangian：

$$
\mathcal{L} = \sum_k f_k(b_k) + \lambda \left(B_s - \sum_k b_k\right)
$$

KKT 条件：

$$
\frac{\partial f_k}{\partial b_k} = \lambda, \quad \forall k \text{ with } b_k > 0
$$

物理解释：**边际效应相等**（water-filling 的本质）。

---

**文档版本**：v1.0
**最后更新**：2024-12
**负责人**：Claude Code Assistant
